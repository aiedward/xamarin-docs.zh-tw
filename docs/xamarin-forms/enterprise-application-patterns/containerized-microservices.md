---
title: 容器化的微服務
description: 本章說明如何使用微服務和容器來建立敏捷式、可調整且可靠的現代化雲端應用程式。
ms.prod: xamarin
ms.assetid: 5872ad92-04e0-4f1a-9691-79d5602f5683
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: dc71da512519cdd7fcc56df1ff987ffbc1354663
ms.sourcegitcommit: eedc6032eb5328115cb0d99ca9c8de48be40b6fa
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/07/2020
ms.locfileid: "78915227"
---
# <a name="containerized-microservices"></a>容器化的微服務

開發用戶端伺服器應用程式的重點是要在每一層中建立使用特定技術的分層式應用程式。 這類應用程式通常稱為整合*型應用程式*，並封裝到預先調整的硬體以進行尖峰負載。 這種開發方法的主要缺點是每一層內的元件緊密結合，個別元件無法輕鬆調整，而且測試成本也很高。 簡單的更新可能會對其餘的階層造成未預期的影響，因此應用程式元件的變更需要重新測試和重新部署整個層。

特別是在雲端存在時，無法輕鬆調整個別元件。 整合型應用程式包含特定領域的功能，通常是由功能層（例如前端、商務邏輯和資料儲存）來劃分。 整合單一應用程式的方式是將整個應用程式複製到多部電腦，如圖8-1 所示。

![](containerized-microservices-images/monolithicapp.png "Monolithic application scaling approach")

**圖 8-1**：整合型應用程式調整方法

## <a name="microservices"></a>微服務

微服務提供不同的應用程式開發和部署方法，這種方法適用于新式雲端應用程式的靈活性、規模和可靠性需求。 微服務應用程式會分解成獨立元件，共同運作以提供應用程式的整體功能。 「微服務」一詞強調，應用程式應該由夠小的服務所組成，以反映獨立的考慮，讓每個微服務都能執行單一函數。 此外，每個微服務都有定義完善的合約，讓其他微服務能夠與它進行通訊及共用資料。 微服務的典型範例包括購物車、清查處理、購買子系統和付款處理。

相較于大規模的整合型應用程式，微服務可以獨立相應放大。 這表示需要更多處理能力或網路頻寬以支援需求的特定功能區域可以調整，而不是不必要地相應放大應用程式的其他區域。 圖8-2 說明此方法，其中微服務會獨立部署和調整，跨電腦建立服務的實例。

![](containerized-microservices-images/microservicesapp.png "Microservices application scaling approach")

**圖 8-2**：微服務應用程式調整方法

微服務向外延展可以幾乎瞬間執行，讓應用程式適應變更的負載。 例如，應用程式之 web 面向功能中的單一微服務可能是應用程式中唯一需要相應放大以處理額外連入流量的微服務。

應用程式擴充性的傳統模型是讓負載平衡的無狀態層具有共用的外部資料存放區，以儲存持續的資料。 具狀態微服務會管理自己的持續性資料，通常會將它儲存在其所在的伺服器本機上，以避免網路存取的額外負荷，以及跨服務作業的複雜性。 這可讓資料的處理速度最快，而且可能會不需要快取系統。 此外，可擴充的具狀態微服務通常會在其實例之間分割資料，以管理單一伺服器可支援的資料大小和傳輸輸送量。

微服務也支援獨立的更新。 這種微服務之間的鬆散結合，可提供快速且可靠的應用程式演進。 其獨立的分散式本質支援輪流更新，其中只有單一微服務的實例子集會在任何指定的時間更新。 因此，如果偵測到問題，則會在所有實例更新為錯誤的程式碼或設定之前，回復錯誤的更新。 同樣地，微服務通常會使用架構版本設定，如此一來，用戶端就會在套用更新時看到一致的版本，而不論與哪一個微服務實例進行通訊。

因此，微服務應用程式對於整合型應用程式有許多優點：

- 每個微服務都相當小，而且易於管理和進化。
- 每個微服務都可以獨立于其他服務的開發和部署。
- 每個微服務都可以獨立相應放大。 例如，目錄服務或購物籃服務可能需要向外擴充，而不是訂購服務。 因此，在相應放大時，產生的基礎結構會更有效率地取用資源。
- 每個微服務都會隔離所有問題。 例如，如果服務發生問題，它只會影響該服務。 其他服務可以繼續處理要求。
- 每個微服務都可以使用最新的技術。 由於微服務是自發且並存執行的，因此可以使用最新的技術和架構，而不是強制使用整合型應用程式可能使用的較舊架構。

不過，以微服務為基礎的解決方案也有潛在的缺點：

- 選擇如何將應用程式分割成微服務可能是一項挑戰，因為每個微服務都必須完全獨立、端對端，包括其資料來源的責任。
- 開發人員必須執行服務間通訊，這會增加應用程式的複雜性和延遲。
- 通常無法在多個微服務之間進行不可部分完成的交易。 因此，商務需求必須採用微服務之間的最終一致性。
- 在生產環境中，部署和管理許多獨立服務的系統遭到入侵時，會有一項操作上的複雜性。
- 直接用戶端對微服務通訊可能會使微服務的合約難以重構。 例如，經過一段時間之後，系統如何分割成服務可能需要變更。 單一服務可能會分割成兩個或多個服務，而且可能會合並兩個服務。 當用戶端直接與微服務通訊時，這種重構工作可能會中斷與用戶端應用程式的相容性。

## <a name="containerization"></a>容器化

容器化是一種軟體發展方法，其中應用程式及其已設定版本的相依性集合，再將其環境設定抽象化為部署資訊清單檔，以容器映射的形式封裝在一起，並測試為一個單位，已部署到主機作業系統。

容器是隔離、受資源控制且可移植的作業環境，其中應用程式可以執行，而不需要觸及其他容器或主機的資源。 因此，容器的外觀和作用就像是新安裝的實體電腦或虛擬機器。

容器和虛擬機器之間有許多相似之處，如圖8-3 所示。

![](containerized-microservices-images/containersvsvirtualmachines.png "Microservices application scaling approach")

**圖 8-3**：虛擬機器和容器的比較

容器會執行作業系統、具有檔案系統，並可透過網路存取，就如同它是實體或虛擬機器。 不過，容器所使用的技術和概念與虛擬機器非常不同。 虛擬機器包含應用程式、必要的相依性，以及完整的客體作業系統。 容器包括應用程式及其相依性，但與其他容器共用作業系統，在主機作業系統上以隔離進程的形式執行（除了在每個容器的特殊虛擬機器中執行的 Hyper-v 容器外）。 因此，容器會共用資源，而且通常需要比虛擬機器更少的資源。

容器導向的開發和部署方法的優點是，它消除了不一致的環境所造成的大部分問題，以及它們所帶來的問題。 此外，容器可以視需要具現化新的容器，以允許快速的應用程式擴充功能。

建立和使用容器時的重要概念如下：

- 容器主機：設定為裝載容器的實體或虛擬機器。 容器主機將會執行一或多個容器。
- 容器映射：映射是由堆疊在彼此之上的多層式檔集所組成，而且是容器的基礎。 映射不具有狀態，而且在部署至不同環境時永遠不會變更。
- 容器：容器是影像的執行時間實例。
- 容器 OS 映像：容器會從映像進行部署。 容器作業系統映射是可能有許多影像層組成容器的第一層。 容器作業系統不可變，而且無法修改。
- 容器存放庫：每次建立容器映射時，映射和其相依性都會儲存在本機儲存機制中。 這些映像可在容器主機上重複使用多次。 容器映射也可以儲存在公用或私用登錄中（例如[Docker Hub](https://hub.docker.com/)），以便在不同的容器主機上使用它們。

企業在實行以微服務為基礎的應用程式時，逐漸採用容器，而 Docker 已成為大部分軟體平臺和雲端廠商採用的標準容器執行。

EShopOnContainers reference 應用程式會使用 Docker 來裝載四個容器化後端微服務，如圖8-4 所示。

![](containerized-microservices-images/microservicesarchitecture.png "eShopOnContainers reference application back-end microservices")

**圖 8-4**： eShopOnContainers 參考應用程式後端微服務

參考應用程式中的後端服務架構會分解成多個自主子系統，其形式為共同微服務和容器。 每個微服務都提供單一功能區域：身分識別服務、目錄服務、訂購服務和購物籃服務。

每個微服務都有自己的資料庫，讓它能夠與其他微服務完全分離。 在必要時，會使用應用層級事件來達成來自不同微服務的資料庫之間的一致性。 如需詳細資訊，請參閱[微服務之間的通訊](#communication_between_microservices)。

如需參考應用程式的詳細資訊，請參閱[.Net 微服務：容器化 .Net 應用程式的架構](https://aka.ms/microservicesebook)。

<a name="communication_between_client_and_microservices" />

## <a name="communication-between-client-and-microservices"></a>用戶端和微服務之間的通訊

EShopOnContainers 行動應用程式會使用*直接用戶端對微服務*通訊（如圖8-5 所示）與容器化後端微服務通訊。

![](containerized-microservices-images/directclienttomicroservicecommunication.png "Microservices application scaling approach")

**圖 8-5**：直接用戶端對微服務通訊

使用直接用戶端對微服務通訊，行動應用程式會透過其公用端點直接對每個微服務提出要求，每個微服務各有不同的 TCP 埠。 在生產環境中，端點通常會對應至微服務的負載平衡器，其會將要求分散到可用的實例。

> [!TIP]
> 請考慮使用 API 閘道通訊。 當您建立大型且複雜的微服務型應用程式時，直接用戶端對微服務通訊可能會有缺點，但對於小型應用程式而言，它就夠多了。 設計具有數十個微服務的大型微服務型應用程式時，請考慮使用 API 閘道通訊。 如需詳細資訊，請參閱[.Net 微服務：容器化 .Net 應用程式的架構](https://aka.ms/microservicesebook)。

<a name="communication_between_microservices" />

## <a name="communication-between-microservices"></a>微服務之間的通訊

以微服務為基礎的應用程式是分散式系統，可能會在多部電腦上執行。 每個服務執行個體通常就是一個處理序。 因此，服務必須使用處理序間通訊協定（例如 HTTP、TCP、Advanced 訊息佇列通訊協定（AMQP）或二進位通訊協定）進行互動，視每個服務的本質而定。

微服務對微服務通訊的兩個常見方法是在查詢資料時以 HTTP 為基礎的 REST 通訊，以及跨多個微服務溝通更新時的輕量非同步訊息。

在多個微服務之間傳播變更時，以非同步訊息為基礎的事件驅動通訊非常重要。 使用這種方法時，微服務會在有問題發生時（例如，當它更新商務實體時）發佈事件。 其他微服務會訂閱這些事件。 然後，當微服務收到事件時，它會更新自己的商業實體，而這可能會導致更多的事件被發佈。 此發佈-訂閱功能通常是透過事件匯流排來達成。

事件匯流排允許微服務之間的發佈-訂閱通訊，而不需要明確察覺元件，如圖8-6 所示。

![](containerized-microservices-images/eventbus.png "Publish-subscribe with an event bus")

**圖8-6：** 發佈-訂閱事件匯流排

從應用程式的觀點來看，事件匯流排只是透過介面公開的發佈-訂閱通道。 不過，事件匯流排的執行方式可能有所不同。 例如，事件匯流排執行可能會使用 RabbitMQ、Azure 服務匯流排或其他服務匯流排，例如 NServiceBus 和 MassTransit。 圖8-7 顯示如何在 eShopOnContainers 參考應用程式中使用事件匯流排。

![](containerized-microservices-images/microservicesarchitecturewitheventbus.png "Asynchronous event-driven communication in the reference application")

**圖8-7：** 參考應用程式中的非同步事件驅動通訊

使用 RabbitMQ 所執行的 eShopOnContainers 事件匯流排提供一對多的非同步發佈訂閱功能。 這表示在發行事件之後，可以有多個訂閱者接聽相同的事件。 圖8-9 說明此關聯性。

![](containerized-microservices-images/eventdrivencommunication.png "One-to-many communication")

**圖 8-9**：一對多通訊

此一對多通訊方法會使用事件來執行橫跨多個服務的商務交易，確保服務之間的最終一致性。 最終一致的交易是由一系列的分散式步驟所組成。 因此，當使用者設定檔微服務收到 UpdateUser 命令時，它會更新其資料庫中的使用者詳細資料，並將 UserUpdated 事件發佈至事件匯流排。 購物籃微服務和訂購微服務都已訂閱接收此事件，並在回應中更新其購買者資訊的個別資料庫。

> [!NOTE]
> 使用 RabbitMQ 所實 eShopOnContainers 的事件匯流排，主要是用來做為概念證明。 針對生產系統，應該考慮替代的事件匯流排執行。

如需事件匯流排執行的相關資訊，請參閱[.Net 微服務：容器化 .Net 應用程式的架構](https://aka.ms/microservicesebook)。

## <a name="summary"></a>總結

微服務提供應用程式開發和部署的方法，其適用于現代化雲端應用程式的靈活性、規模和可靠性需求。 微服務的主要優點之一，就是可以獨立相應放大，這表示可以調整特定功能區域，而需要更多處理能力或網路頻寬來支援需求，而不需不必要的調整區域應用程式不會遇到增加的需求。

容器是隔離、受資源控制且可移植的作業環境，其中應用程式可以執行，而不需要觸及其他容器或主機的資源。 企業在實行以微服務為基礎的應用程式時，逐漸採用容器，而 Docker 已成為大部分軟體平臺和雲端廠商採用的標準容器執行。

## <a name="related-links"></a>相關連結

- [下載電子書（2 Mb 的 PDF）](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers （GitHub）（範例）](https://github.com/dotnet-architecture/eShopOnContainers)
