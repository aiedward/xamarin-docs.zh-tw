---
title: 使用 Xamarin 進行遊戲開發的簡介
description: 本檔提供使用 Xamarin 進行遊戲開發的高階總覽，同時描述遊戲的建立方式，以及可與 Xamarin 和 Xamarin 搭配使用的技術取樣。
ms.prod: xamarin
ms.assetid: 0E3CDCD2-FBE4-49F5-A70E-8A7B937BAF1D
author: conceptdev
ms.author: crdun
ms.date: 03/24/2017
ms.openlocfilehash: 8f7ec5175895a31746710fad9ea7372052b698ff
ms.sourcegitcommit: 008bcbd37b6c96a7be2baf0633d066931d41f61a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/22/2020
ms.locfileid: "86936483"
---
# <a name="introduction-to-game-development-with-xamarin"></a>使用 Xamarin 進行遊戲開發的簡介

開發遊戲可能非常令人興奮，特別是在行動平臺上發佈工作有多麼容易。 本文將討論與遊戲開發相關的概念和技術，以協助您建立遊戲，無論您的目標是建立高品質的 AAA 遊戲，或只是要為您提供更有趣的程式。

本文章涵蓋下列主題：

- **遊戲與非遊戲程式設計概念**--我們將探討遊戲開發獨有的一些概念，或與其他類型的開發共用，但基於重要性而值得強調。
- **遊戲開發團隊**–本節探討遊戲開發人員小組的各種角色。
- **建立遊戲的想法**–本節可協助您建立新遊戲的第一步，也就是建立新的遊戲。
- **遊戲開發技術**–這裡會列出一些可讓您以遊戲開發人員的形式改善生產力的跨平臺技術。

## <a name="game-vs-non-game-programming-concepts"></a>遊戲與非遊戲程式設計概念

移至遊戲開發的程式設計人員通常會面臨新的概念和開發模式。 本節提供其中一些概念的高階觀點。

### <a name="the-game-loop"></a>遊戲迴圈

典型的遊戲需要在螢幕上進行持續移動或變更，以回應使用者互動和自動遊戲邏輯。 這是透過通常稱為*遊戲迴圈*的方式來達成。 遊戲迴圈是某種類型的迴圈語句（例如 while 迴圈），會以非常高的頻率執行，例如*每秒*30 或60個畫面格。

以下是簡單遊戲迴圈的圖表：

![這是簡單遊戲迴圈的圖表](images/image1.png)

我們在下面討論的技術將會抽象出實際的 while 迴圈，但儘管此抽象概念，每個畫面格的更新都將出現。

即使是最簡單的遊戲，程式碼效能也可能優先。 例如：需要10毫秒執行的函式可能會對遊戲效能造成重大影響，特別是在每個畫面上呼叫一次以上時。 如果您的遊戲在每秒30個畫面上執行，則表示每個畫面格必須在33毫秒的時間內執行。 相反地，如果只是為了回應非遊戲應用程式中的按鈕按一下而執行，則這類函式可能甚至不明顯。

可以每個畫面格執行的一般邏輯類型包括：

- **讀取輸入**–遊戲可能需要檢查輸入硬體（例如觸控式螢幕、鍵盤、滑鼠或遊戲控制器），以確認使用者是否已與遊戲互動。
- **移動**–從一個位置移到另一個位置的物件通常會移動非常小的每個畫面格，以提供流暢動作的假像。
- **衝突**–許多遊戲都需要經常測試各種物件是否重迭或相交。 我們將在本文稍後的章節中深入探討衝突。 移動和衝突可能會由專用的物理模擬系統處理。
- **檢查遊戲特有的條件**–遊戲的狀態可能會受到特定條件控制，例如玩家是否已有足夠的點數，或是否已有時間已用盡。
- **AI 行為**–每個畫面格的邏輯，可用來控制不受播放程式控制之物件的行為，例如敵人的 patrolling 或在 racetrack 的運動。
- 轉譯 **–大部分**的遊戲都會更新螢幕上每個畫面格所顯示的內容。 這可能是為了回應對遊戲播放有影響的變更（例如，透過層級移動的字元），或只是提供視覺效果波蘭文（例如下降的雪或動畫圖標）。

請記住，以上所列的許多活動都可以變更整個應用程式的狀態，而許多非遊戲應用程式通常會變更狀態以回應所引發的事件。

### <a name="content-loading-and-unloading"></a>內容載入和卸載

視您在開發中使用的技術而定，可能需要手動載入及卸載（或處置）內容。 手動載入和卸載資產可能有許多原因：

- 資產可能會花很長的時間載入相對於單一框架的長度。 某些資產可能甚至需要幾秒鐘的時間才能載入，這會嚴重中斷載入遊戲時的體驗。 如果載入時間較長（例如超過一秒或兩個），您可能會想要顯示動畫載入畫面或進度列。
- 資產可能會耗用大量的 RAM，需要主動管理所載入的內容，以符合遊戲的目標平臺所提供的功能。
- 遊戲可能需要顯示的資產超過 RAM 所能容納的數量。 「開放式世界」遊戲通常包含大型環境，讓玩家可以順暢地流覽，也就是沒有任何載入畫面。 在此情況下，您可能需要建立自訂系統，以便在中串流內容和管理記憶體使用量。

自訂檔案格式可能需要在載入時處理，需要自訂的載入程式碼。

### <a name="math"></a>數學

許多遊戲都需要比非遊戲應用程式更先進的數學運算。 當然，數學的層級取決於遊戲的複雜度。 在一般的3D 遊戲中，需要比2D 更多的數學運算。 幸運的是，您隨時都可以開始使用簡單的遊戲，並快速學習。 遊戲開發是學習數學的絕佳方式！

如果您熟悉笛卡兒平面（使用 X 和 Y 座標來定位物件），則您知道要開始進行遊戲開發。 以下顯示正面 Y 指向向上的笛卡兒平面：

![這會顯示正 Y 指向向上的笛卡兒平面](images/image2.png)

> [!IMPORTANT]
> 某些引擎/Api 會使用座標系統，其中增加物件的 Y 值會將其向下移動，而其他系統則使用正 Y 已啟動的座標系統。 如果您要在系統之間移動，請記住這一點。
三角函數（例如正弦和余弦）常用於實作為旋轉形式的2D 遊戲中。

如果您打算進行3D 遊戲，則您可能需要熟悉線性代數（用於3D 空間中的旋轉和移動）以及一些微積分（用於執行加速）的概念。

### <a name="content-pipelines"></a>內容管線

「*內容管線*」一詞指的是在遊戲中使用時，檔案從其格式（例如 .png 影像檔）取得其最終格式所需的處理常式。 結束格式取決於所使用的內容類型，以及用來呈現內容的技術。

某些內容管線可能非常快速，而且不需要手動操作。 例如，大部分的遊戲引擎和 Api 都可以用其未處理的格式載入 .png 檔案格式。 另一方面，在載入之前，可能需要將更複雜的格式（例如3D 模型）處理成不同的格式，而且這種處理可能需要一些時間，視資產的大小和複雜度而定。

## <a name="game-development-teams"></a>遊戲開發小組

遊戲開發為涉及程式的個人引進了新的角色和標題。 大部分的遊戲開發人員都無法滿足發行全遊戲所需的廣泛技能，因此有許多專業領域。 請記住，這不是開發領域的完整清單，只是一些常見的部分。

- 程式設計**人員–閱讀**本文的大部分人都屬於此類別。 程式設計人員在遊戲開發方面的角色，與在非遊戲應用程式中的程式設計師角色類似。 責任包括撰寫邏輯來控制遊戲的流程、在指定專案的內容中開發一般工作的系統、新增和顯示內容，以及修正錯誤。
- **2d 演出者**–2d 演出者負責建立*2d 資產*。 其中包括遊戲的 GUI、微粒、環境和字元的影像檔案。 如果您所開發的遊戲是3D，則2D 演出者可能不會負責環境和字元。 您可以在上找到適用于遊戲的免費圖片 [http://opengameart.org/](http://opengameart.org/) 。
- **3d 演出者**–3d 演出者負責建立*3d 資產*。 這些包括適用于環境、字元和 .props （傢俱、植物和其他無生命物件）的3D 模型。 有些小組會根據小組的大小，區分3D 演出者和 3D animators。 您可以在上找到適用于遊戲的免費3D 圖案 [http://opengameart.org/](http://opengameart.org/) 。
- **遊戲設計**工具–遊戲設計人員負責定義遊戲的播放方式。 這可能包括高階決策，例如遊戲的設定、遊戲的整體目標，以及玩家如何透過遊戲執行。 遊戲設計人員也可以參與非常詳細的決策，例如將輸入對應至動作、定義移動或層級的係數，以及設計層級版面配置。 請記住，「*設計師*」一詞可能會參照「遊戲設計工具」或「視覺化設計工具」（視內容而定）。
- **音效設計**工具–音效設計工具負責遊戲的音訊資產。 有些小組可能會區分負責建立音效效果和作曲家的個人，而較小的小組則可能會有單一個體負責所有音訊。

## <a name="creating-a-game-idea"></a>建立遊戲想法

設計遊戲可能會變得很容易，但在所有的需求都是「讓事情更有趣」之後。 可惜的是，許多開發人員在建立要開始開發的想法時，會發現自己遺失。

遊戲設計的專業領域並不容易解釋，而且需要練習改進，如同美工或程式設計一樣，但本節可協助您從路徑開始。

新的開發人員應該從小規模開始。 重現大型、新式的影片遊戲可能會很麻煩，但較小的遊戲可以是更佳的學習環境，而更快速的進展則是提供更好的體驗。

許多遊戲都是針對學習和商業遊戲，從現有遊戲的改進或修改開始。 產生想法的其中一種方式是查看其他遊戲的靈感。 例如，您可以考慮自己個人喜歡的遊戲，並嘗試識別遊戲玩的哪些特性讓它更有趣。 它可能是探索、熟悉遊戲的機制，或在一整個案例中進行。 在搜尋新想法時，別忘了考慮「懷舊」的遊戲。

產生新想法的另一個技巧，就是考慮特定的內容類型，例如謎題遊戲、策略遊戲或 platformers。 開發人員所熟悉的內容類型可能會提供一個良好的起點。

改造現有的遊戲也是教育經驗，不過這可能會限制已完成的產品的商業可用性。 建立遊戲的程式，甚至是精確的複製品，都能提供寶貴的教育經驗。

## <a name="game-development-technology"></a>遊戲開發技術

使用 Xamarin 和 Xamarin 的開發人員，有各式各樣的技術可協助開發遊戲。 本節將討論一些最受歡迎的跨平臺解決方案。

### <a name="monogame"></a>MonoGame

MonoGame 是 Microsoft 的高階應用程式開發介面的開放原始碼跨平臺版本。 MonoGame 可以用來為 iOS、Android、Mac OS X、Linux、Windows、Windows RT、PS4、PSVita、Xbox One 和交換器製作遊戲。

MonoGame 在技術上並不是遊戲引擎，而是遊戲開發 API。 這表示，使用 MonoGame 需要直接管理遊戲物件、手動繪製物件，以及執行相機和*場景圖形*（遊戲物件之間的父子階層）之類的一般物件。

MonoGame 不提供標準的視覺化開發環境，因此使用 MonoGame 需要程式設計知識。

使用 MonoGame 之遊戲的值得注意範例包括：

FEZ:

![FEZ](images/image7.png)

起

![Bastion](images/image8.jpg)

若要開始使用 MonoGame，請前往我們的[MonoGame 指南](~/graphics-games/monogame/index.md)。

### <a name="urhosharp"></a>UrhoSharp

UrhoSharp 是跨平臺的高階3D 和2D 引擎，可以用來為您的應用程式建立使用幾何、材質、光源和相機的動畫3D 和2D 場景。

![UrhoSharp 是跨平臺的高階3D 和2D 引擎，可以用來建立動畫3D 和2D 場景](images/urhosharp.gif)

請參閱[UrhoSharp 指南](~/graphics-games/urhosharp/index.md)以開始使用。

### <a name="additional-technology"></a>其他技術

上面反白顯示的技術只是可用技術的範例。 其他值得注意的技術包括：

- **Sprite 套件**– Xamarin 提供 Apple 的 sprite 套件遊戲架構的支援，可讓您存取原生 API 的所有功能。 由於 Sprite 套件是 Apple 所建立的技術，因此提供與其他 iOS 生態系統的深入整合。 當然，Sprite 套件不是跨平臺，因此無法在 Android 上使用。 如需使用 Sprite 套件的詳細資訊，請參閱這篇文章：[https://blog.xamarin.com/make-games-with-xamarin.ios-and-sprite-kit/](https://blog.xamarin.com/make-games-with-xamarin.ios-and-sprite-kit/)
- **場景套件**– Xamarin 也提供 Apple 場景套件架構的支援，這可簡化將3d 圖形實作為 iOS 應用程式的流程。 場景套件也是 Apple 所提供的技術，因此其具備上述的整合和平臺特定考慮，可供 Sprite 套件使用。 如需場景套件的詳細資訊，請參閱這篇文章：[https://blog.xamarin.com/3d-in-ios-8-with-scene-kit/](https://blog.xamarin.com/3d-in-ios-8-with-scene-kit/)
- **Opentk 簡介–** Opentk 簡介（代表開放工具套件）提供 iOS、Apple 和 Mac 硬體的低層級 OpenGL 存取。 如需 Opentk 簡介的詳細資訊，請參閱主要頁面，網址為：[https://opentk.net/](https://opentk.net/)

## <a name="related-links"></a>相關連結

- [MonoGame 指南](~/graphics-games/monogame/index.md)
- [UrhoSharp 指南](~/graphics-games/urhosharp/index.md)
