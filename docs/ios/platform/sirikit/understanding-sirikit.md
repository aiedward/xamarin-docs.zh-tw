---
title: 了解 SiriKit 概念
description: 本檔說明在 Xamarin iOS 應用程式中使用 SiriKit 時所需的重要概念。 例如，它會討論意圖和意圖 UI 延伸、SiriKit 許可權、設計絕佳的體驗等等。
ms.prod: xamarin
ms.assetid: 99EC5C1E-484F-4371-8555-58C9F60DE37F
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 05/02/2017
ms.openlocfilehash: 74c45a4e8880e1b9c98d11dd4874a4ecf569f0c0
ms.sourcegitcommit: 00e6a61eb82ad5b0dd323d48d483a74bedd814f2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/29/2020
ms.locfileid: "91433798"
---
# <a name="understanding-sirikit-concepts"></a>了解 SiriKit 概念

_本文涵蓋在 Xamarin iOS 應用程式中使用 SiriKit 時所需的重要概念。_

SiriKit 是 iOS 10 的新功能，可讓 Xamarin iOS 應用程式提供可讓使用者使用 Siri 和 iOS 裝置上的 Maps 應用程式存取的服務。 這項功能會在一或多個使用新 **意圖** 和 **意圖 UI** 架構的應用程式擴充功能中提供。

SiriKit 可讓 iOS 應用程式使用應用程式擴充功能和新的 **意圖** 和 **意圖 UI** 架構，提供可讓使用者在 IOS 裝置上使用 Siri 和地圖應用程式存取的服務。

Siri 適用于 **領域**的概念、相關工作的已知動作群組。 應用程式與 Siri 之間的每個互動都必須屬於其中一個已知的服務網域，如下所示：

- 正在呼叫音訊或影片。
- 預約。
- 管理 workouts。
- 消息。
- 正在搜尋相片。
- 傳送或接收款項。

當使用者要求包含其中一個應用程式延伸模組服務的 Siri 時，SiriKit 會傳送一個 **意圖** 物件給延伸模組，該物件會描述使用者的要求以及任何支援的資料。 然後，應用程式延伸模組會為指定的**意圖**產生適當的**回應**物件，詳述延伸模組如何處理要求。

## <a name="the-intents-and-intents-ui-extensions"></a>意圖和意圖 UI 延伸模組

Siri 和 Maps 應用程式都會透過兩種不同類型的應用程式延伸模組與應用程式的服務互動：

- **意圖延伸** 模組-提供 Siri 和地圖與應用程式的內容，並執行滿足任何支援意圖所需的工作。
- **意圖 UI 延伸** 模組-提供將在 Siri 或 Maps 內針對應用程式內容顯示的自訂 UI。

應用程式必須提供意圖延伸模組以支援 SiriKit，並負責提供 Siri 和 Maps 可呈現給使用者的資訊，以及處理意圖。

建立意圖 UI 延伸模組是選擇性的，因為 Siri 通常會處理所有使用者互動，而且具有標準的內建 UI，可在每個支援的網域中呈現資訊。 藉由提供意圖 UI 延伸模組，應用程式可以使用 **意圖 ui** 架構來呈現豐富的自訂消費者介面，其中包含應用程式的商標和其他資訊。

## <a name="siri-and-the-maps-app-role"></a>Siri 和 Maps 應用程式角色

使用者的語音要求由 Siri 處理，並以語義方式分析，進而將這些要求變成意圖延伸模組可以處理的可操作意圖。

地圖會使用應用程式的意圖延伸來顯示地圖介面中的資訊，以回應使用者的動作。 例如要求附近餐廳或取得應用程式餐廳評論。

Siri 和 Maps 都會使用標準系統介面來管理所有使用者的互動，並顯示結果。 應用程式延伸模組角色主要是提供所顯示的資料。 （選擇性）應用程式可以提供意圖 UI 延伸，並顯示自訂 UI 以增強預設系統介面。

## <a name="interacting-with-siri-via-sirikit"></a>透過 SiriKit 與 Siri 互動

本節將概述 SiriKit 如何讓使用者使用 Siri 與應用程式互動。 基於此範例，我們將使用假的 MonkeyChat 應用程式：

[![MonkeyChat 圖示](understanding-sirikit-images/monkeychat01.png)](understanding-sirikit-images/monkeychat01.png#lightbox)

MonkeyChat 會保留自己的使用者朋友的連絡人，每個都與螢幕名稱相關聯 () 例如 Bobo），並可讓使用者以螢幕名稱將文字聊天室傳送給每位朋友。

有許多方式可讓使用者起始與應用程式的互動，因為不同的人可能會在許多不同的表單中提出相同的要求。

例如，如果使用者想要將訊息傳送至其 friend Bobo，他們可能會有下列與 Siri 的交談：

_使用者：嘿 Siri，傳送 MonkeyChat 訊息。_<br />
_Siri：對誰？_<br />
_使用者： Bobo。_<br />
_Siri：您想要 Bobo 什麼？_<br />
_使用者：請傳送更多香蕉。_<br />

另一個人可能會對不同的交談提出相同的要求：

_使用者：在 MonkeyChat 上將訊息傳送至 Bobo。_<br />
_Siri：您想要 Bobo 什麼？_<br />
_使用者：請傳送更多香蕉。_<br />

另一位使用者可能會產生更短的要求：

_使用者： MonkeyChat Bobo 請傳送更多香蕉。_<br />
_Siri：確定傳送訊息，請在 Monkeychat 上傳送更多香蕉給 Bobo。_<br />

甚至在不同的語言中建立相同的要求：

_User： MonkeyChat Bobo s'il vous plaît envoyer plus de bananes。_<br />
_Siri： Oui、envoi message s'il vous plaît envoyer plus de bananes à Bobo sur Monkeychat。_<br />

但另一位使用者在其對話中可能非常詳細：

_使用者：嘿 Siri，您可以這麼做，並啟動 MonkeyChat 應用程式以傳送文字，訊息請傳送更多香蕉。_<br />
_Siri：對誰？_<br />
_使用者：我的最佳 pal Bobo。_<br />

此外，也有許多方式可讓 Siri 根據要求的執行方式來回應要求：

- 藉**由保留 [首頁] 按鈕**，Siri 會提供更多的視覺回應，並提供有限的口頭意見反應。
- 「**嗨 Siri** 」-Siri 將會比較口頭，並提供較少的視覺回應。

Siri 也會進行調整以符合使用者的協助工具需求，並且會根據這些需求進行互動和回應。

無論提出要求的方式或 Siri 回應要求的方式為何，Siri 都會處理與使用者的交談，並透過其擴充功能 (應用程式) 提供功能。

當使用者對 Siri 提出口頭要求時，這些是 Siri 將遵循的步驟：

[![Siri 將遵循的步驟](understanding-sirikit-images/monkeychat02.png)](understanding-sirikit-images/monkeychat02.png#lightbox)

1. 首先，Siri 會取得使用者 **語音** 的音訊，並將其轉換成文字。
2. 接著，文字會轉換成 **意圖**，這是使用者要求的結構化標記法。
3. 根據意圖，Siri 會採取 **動作** 來執行使用者的要求。
4. 最後，Siri 會根據所採取的動作， (視覺效果和口頭) 的 **回應** 呈現給使用者。

有三種主要方式可讓應用程式參與使用者與 Siri 的對話：

[![應用程式可參與使用者對話的三種主要方式 Siri](understanding-sirikit-images/monkeychat03.png)](understanding-sirikit-images/monkeychat03.png#lightbox)

1. **詞彙** -這是應用程式告訴 Siri 需要知道的單字與其互動的方式。
2. **應用程式邏輯** -這些是應用程式會根據指定意圖採取的動作和回應。
3. **消費者介面** -這是選擇性的自訂使用者介面，可讓應用程式在中提供回應。

### <a name="example"></a>範例

提供上述資訊之後，請檢查下列對話如何與 MonkeyChat 應用程式互動：

_使用者：嘿 Siri，將訊息傳送至 MonkeyChat 上的 Bobo。_<br />
_Siri：您想要 Bobo 什麼？_<br />
_使用者：請傳送更多香蕉。_<br />

應用程式在對話中所採取的第一個角色是協助 Siri 瞭解使用者的語音：

[![協助 Siri 瞭解使用者語音](understanding-sirikit-images/monkeychat04.png)](understanding-sirikit-images/monkeychat04.png#lightbox)

Siri 在其資料庫中的名稱不是 "Bobo"，但應用程式會透過其詞彙與 Siri 共用這項資訊。 此應用程式也可協助 Siri 辨識 Bobo 是收件者，因為它會將其指定為以 *連絡人*的形式 Siri。

Siri 知道需要更多的訊息才能傳送訊息，而不只是收件者，因此它會快速檢查應用程式延伸模組，以查看訊息是否需要內容。 由於 MonkeyChat 的原因，Siri 會以下列問題回應使用者：「*您想要 Bobo 什麼？* 」

在上述範例中，使用者已回應：「 *請傳送更多香蕉*」，Siri 將會組合成結構化 **意圖**：

[![Siri 會將使用者的回應組合成結構化的意圖](understanding-sirikit-images/monkeychat05.png)](understanding-sirikit-images/monkeychat05.png#lightbox)

結構化意圖將包含下列資訊：

- **網域：** 消息
- **意圖：** sendMessage
- **收件者：** 波波
- **內容：** 請傳送更多香蕉

每個網域都有一組可在其中執行的已知 *動作* ，以及根據網域和動作，在傳送至應用程式的意圖中可能會包含零到多個參數。

然後，會將意圖傳送至應用程式延伸模組進行處理。 由於處理意圖的結果，應用程式將會產生 **IntentResponse** ，並將其與意圖配套，並包含描述應用程式如何使用意圖的參數。

每個 IntentResponse 也會包含 **回應碼** ，告知 Siri 應用程式是否能夠完成要求。 某些網域具有非常特定的錯誤回應碼，也可以傳送。

最後，IntentResponse 會包含 `NSUserActivity` (，就像是用來支援) 的手。 `NSUserActivity`如果回應要求他們離開 Siri 環境，並輸入應用程式來完成應用程式，將會使用來啟動應用程式。

Siri 會自動建立適當的 `NSUserActivity` 來啟動應用程式，並挑選使用者在 Siri 環境中離開的位置。 但是，如果需要的話，應用程式可以提供 `NSUserActivity` 自訂的資訊。

在應用程式處理意圖並將回應傳回給 Siri 之後，它會將結果呈現給使用者， (verbally 和以視覺化方式) ：

[![以視覺化方式呈現給使用者的結果 verbally](understanding-sirikit-images/monkeychat06.png)](understanding-sirikit-images/monkeychat06.png#lightbox)

Siri 有數個內建的回應使用者介面，可供應用程式使用的每個網域使用。 不過，由於 MonkeyChat 已提供選用意圖 UI 延伸模組，因此它會用來向使用者呈現上述範例中的交談結果。

## <a name="the-intent-lifecycle"></a>意圖生命週期

處理意圖時，應用程式延伸模組將需要執行三個主要工作：

[![意圖生命週期](understanding-sirikit-images/monkeychat07.png)](understanding-sirikit-images/monkeychat07.png#lightbox)

1. 應用程式必須 **解析** 事件上的每個參數。 因此，應用程式會針對每個參數) 呼叫多次 (一次，有時會在相同的參數上多次呼叫，直到應用程式和使用者同意所要求的內容為止。
2. 應用程式必須 **確認** 它可以處理要求的意圖，並告知 Siri 預期的結果。
3. 最後，應用程式必須 **處理** 意圖，並執行步驟以達成要求的結果。

### <a name="the-resolve-stage"></a>解析階段

解決階段有助於 Siri 瞭解使用者所提供的值，並確保使用者實際代表的是應用程式處理意圖時，會發生什麼事。

此階段也可讓應用程式在與使用者交談期間影響 Siri 的行為。 若要這樣做，應用程式將會提供 **解決方案回應**。 針對 Siri 瞭解的不同資料類型，有許多預先定義的回應。

來自應用程式的最常見解決回應將會 **成功**，這表示應用程式會比對參數中的特定資料片段 (例如使用者畫面名稱) 到它知道的資訊片段。

有時候，應用程式可能需要確認指定的要求符合它所知道的正確資訊片段。 在這些情況下，它會傳送 **ConfirmationRequired** 回應以對使用者提出「是」或「不是」問題，例如「 *傳送訊息給 Bobo 很棒嗎？」。*

在其他情況下，應用程式可能會要求使用者從簡短的選項清單中挑選。 在此情況下，應用程式會提供 **混淆回應，** 其中包含二到十個選項的清單，供使用者選擇，例如：

```csharp
Who do you want to message?

* Bobo the Great
* Bobo Jr.
* Little Bobo
```

Siri 會處理使用者進行選取的專案，不論是 verbally 或與 Siri UI 互動，都會將結果傳送回應用程式。

在其他情況下，可能沒有足夠的資訊可讓應用程式解析參數，或可能有太多相符專案可使用去除混淆 (（例如名稱) 中有 Bobo 的使用者80）解析。 在此情況下，應用程式會傳送 **NeedsMoreDetails** 回應，而 Siri 會提示使用者更明確。

如果使用者未提供處理意圖所需的值，它可以傳送 **NeedsValue** 回應，讓 Siri 提示使用者輸入值。

如果應用程式不支援使用者為特定參數指定的值，它可以傳送 **UnsupportedWithReason** 回應，以提供不支援值的原因。 然後，Siri 會提示使用者提供全新的值，並指定其所需的原因。

最後，使用 **NotRequired** 回應來告訴 Siri，應用程式不需要指定參數的值。 如果使用者仍然提供，則 Siri 會忽略它。

### <a name="the-confirm-stage"></a>確認階段

確認階段有兩個用途：

- 為了告訴 Siri 處理意圖的預期結果，讓 Siri 能夠告訴使用者即將發生什麼事。
- 提供一個機會，檢查應用程式可能需要完成使用者提出要求所需的任何狀態，例如在銀行內有足夠的款項來進行要求的付款。

應用程式會從確認步驟提供 **意圖回應** ，這應該會填入應用程式可用的最多資訊，讓 Siri 可以與使用者有效地進行通訊。

根據 [網域] 和 [動作類型]，Siri 可能會提示使用者進行確認，例如傳送付款或預約。

### <a name="the-handle-stage"></a>控制碼階段

控制碼階段是使用意圖的最重要部分，因為它是應用程式執行所要求的工作來滿足使用者要求的點。

就像在確認階段一樣，應用程式需要盡可能提供結果的相關資訊，讓 Siri 可以與使用者產生關聯。 有時，這種資訊會以視覺化方式呈現，或在其他的時候 Siri 會直接向使用者顯示。

有時候，應用程式可能需要額外的時間來處理指定的要求，例如網路呼叫延遲或 live person 需要履行要求 (例如完成和傳送訂單，或是推動汽車到使用者的位置) 。 當 Siri 正在等候應用程式傳迴響應時，會向使用者顯示等候中的 UI，告訴他們應用程式正在處理要求。

在理想的情況下，應用程式最多隻能在兩到三秒內提供 Siri 的回應。 如果應用程式知道指定的回應需要較長的時間來處理，則必須將 **InProgress** 回應碼傳送至 Siri。 然後，Siri 會通知使用者應用程式正在背景處理要求，即使離開 Siri 環境，也會繼續執行。

## <a name="adding-sirikit-to-the-app"></a>將 SiriKit 新增至應用程式

使用 iOS 10 的 SiriKit，Apple 已建立兩個新的擴充點：

- **意圖延伸** 模組-提供 Siri 與應用程式的內容，並執行滿足任何支援意圖所需的工作。
- **意圖 UI 延伸** 模組-提供將針對 Siri 內的應用程式內容顯示的自訂 UI。

另外還有一個 API 可提供單字和片語來 Siri，以協助辨識的形式如下：

- **應用程式詞彙** -每個應用程式使用者通用的單字和片語。
- **使用者詞彙** ：特定應用程式使用者唯一的單字和片語。

## <a name="the-intents-extension"></a>意圖延伸

意圖延伸模組負責處理應用程式與 Siri 之間的主要互動，如下所示：

[![意圖延伸](understanding-sirikit-images/intents01.png)](understanding-sirikit-images/intents01.png#lightbox)

意圖延伸模組可以支援一或多個意圖，而開發人員可自行決定是否要在應用程式中執行 SiriKit。 開發人員也可以針對每個需要處理的意圖新增個別的意圖延伸。  也就是說，Apple 要求開發人員限制意圖延伸的數目，讓 Siri 不會針對應用程式開啟多個進程，這需要更多的記憶體和時間來處理。

開發人員也應該注意，當 Siri 為使用中時，意圖延伸模組將會在背景中執行。 這可讓 Siri 主動與使用者交談，同時仍會與延伸模組通訊以處理要求的相關資訊。

## <a name="privacy-and-security-considerations"></a>隱私權和安全性考量

Apple 已採用絕佳的措施，以確保使用者在使用 Siri 時的私用資訊是安全的，因此，需要使用者在 iOS 裝置上登入的數個互動。 例如，要求提出或付款。

此外，應用程式可能會想要限制使用者登入裝置的特定行為。 在這些情況下，應用程式可以在 **鎖定行為時要求限制** 。 這是透過檔案中的設定來完成 `Info.plist` 。

本機驗證架構適用于意圖延伸模組，因此應用程式可以詢問使用者是否有其他驗證資訊，即使裝置已解除鎖定。

最後，Apple Pay 適用于意圖延伸模組，因此應用程式可以使用 Apple Pay 來完成交易，而內建的 Apple Pay 表會顯示在 Siri 介面的上方。

此外，Apple 想要確保使用者知道何時將資訊傳送到協力廠商應用程式，因此使用者 **必須** 說出應用程式的特定名稱 (如提出要求時，應用程式套件組合顯示名稱) 中所指定。

Apple 已設計 Siri 來與使用者進行自然、流暢的對話，因此，應用程式的套件組合名稱可用於許多部分的語音，不論它是在使用者的要求中自然放在哪裡。

使用者要做的其中一件事，就是「verbify」應用程式的名稱，也就是使用應用程式名稱，並使用它作為要求中的動詞。 例如，「 *MonkeyChat Bobo 這些都是絕佳的香蕉」。*

## <a name="the-intents-ui-extension"></a>意圖 UI 延伸模組

意圖 UI 延伸模組提供了一個機會，讓應用程式的 UI 和商標進入 Siri 體驗，並讓使用者感覺能夠連線到應用程式。 使用此延伸模組，應用程式可以將品牌以及視覺效果和其他資訊帶入文字記錄中。

[![範例意圖 UI 延伸輸出](understanding-sirikit-images/intents02.png)](understanding-sirikit-images/intents02.png#lightbox)

意圖 UI 延伸模組一律會傳回 `UIViewController` ，而且應用程式可以將它喜歡的任何內容加入至 view controller 內，例如顯示超出初始回應的其他資訊。 意圖 UI 也可以使用長時間執行事件的狀態來更新使用者，例如，要花多少時間才能讓共用車輛到達其位置。

意圖 UI 延伸模組一律會與其他 Siri 內容一起顯示，例如 UI 頂端的應用程式圖示和名稱，或者根據意圖，按鈕 (例如 [傳送] 或 [取消]) 可能會顯示在底部。

有幾個實例，應用程式預設會將 Siri 顯示的資訊取代為使用者（例如訊息或地圖），應用程式可以將預設體驗取代為應用程式所量身訂做的體驗。

> [!IMPORTANT]
> 雖然可以將互動式專案（例如或）新增 `UIButtons` `UITextFields` 至意圖 ui 延伸模組，但 `UIViewController` 這些專案在非互動式的意圖 ui 中是完全禁止的，使用者將無法與其互動。

這完全是選擇性的，讓應用程式提供意圖 UI 延伸模組，因為 Siri 包含每個意圖型別的一組預設的 UI。 此外，意圖 UI 介面僅適用于 Apple 所認為對使用者很有説明的特定意圖。

## <a name="adding-sirikit-vocabulary"></a>新增 SiriKit 詞彙

執行 SiriKit 的最後一個部分是在應用程式中提供所需的詞彙。 許多應用程式都有獨特的方式來描述使用者的資訊，以及使用者將提供資訊給應用程式的獨特方式。

因此，Siri 需要應用程式的協助，才能瞭解應用程式專屬的單字和片語。 其中某些片語將會是應用程式的一部分，讓每位使用者都知道並瞭解它們。 此外，其他使用者對應用程式的特定使用者來說都是唯一的。

### <a name="app-specific-vocabulary"></a>應用程式特定詞彙

應用程式特定詞彙會定義所有應用程式使用者都知道的特定單字和片語，例如車輛類型或健身名稱。 因為這些都是應用程式的一部分，所以會在檔案中定義為主要應用程式套件組合的 `AppIntentVocabulary.plist` 一部分。 此外，這些字組和片語都應該當地語系化。

詞彙檔案有幾個部分 `AppIntentVocabulary.plist` ：

- **範例應用程式使用** -這些會針對使用者可為應用程式建立的要求提供一組常見的使用案例。 例如： *「使用 MonkeyFit 開始測驗」。*
- **參數** -這些會提供應用程式專用的一組非標準參數類型。 例如，MonkeyFit 應用程式的測驗名稱。 這些包括：
  - **片語** -可讓應用程式定義應用程式的唯一字詞。 例如：適用于 MonkeyFit 應用程式的 "Bananarific" 測驗類型。
  - **發音** -提供發音提示給 Siri，作為指定片語的簡單語音拼寫。 例如 "ba nana ri fic"。
  - **範例** ：提供在應用程式中使用指定片語的範例。 例如， *「在 MonkeyFit 中啟動 Bananarific」*。

如需詳細資訊，請參閱 Apple 的 [應用程式詞彙檔案格式參考](https://developer.apple.com/library/prerelease/content/documentation/Intents/Conceptual/SiriIntegrationGuide/CustomVocabularyKeys.html#//apple_ref/doc/uid/TP40016875-CH10-SW1)。

### <a name="user-specific-vocabulary"></a>使用者特定詞彙

使用者特定詞彙將提供應用程式個別使用者專屬的單字或片語。 系統會從主要應用程式在執行時間提供這些功能， (不是應用程式延伸模組) 為使用者最重要的使用優先順序所排序的一組詞彙，在清單開頭最重要的詞彙。

請看一下上面顯示的 MonkeyChat 應用程式範例。 MonkeyChat 會保留所有使用者的連絡人清單，透過使用者特定詞彙傳送給 Siri。 它也會保留使用者已 messaged 的10個最新連絡人清單，且每位使用者都有一組最愛的連絡人。 在此範例中，我的最愛連絡人應位於使用者特定詞彙的開頭，後面接著最近的連絡人，然後是使用者連絡人的其餘部分。

使用者特定詞彙支援下列類型的資訊：

- 連絡人名稱。
- 測驗名稱。
- 相片專輯名稱。
- 相片關鍵字。

如果應用程式依賴 iOS 通訊錄，應用程式就不需要採取任何動作，因為這項資訊已可供 Siri。 如果應用程式有自己唯一的連絡人資料庫，則應用程式只需要提供連絡人名稱。

設計詞彙時，請只提供使用者知道和在意的必要值。 避免提供電話號碼或電子郵件地址等資訊。

應用程式也需要在使用者特定詞彙變更時立即更新 Siri。 使用者習慣從 Siri 要求資訊，它已新增至其 iOS 裝置。 例如，如果使用者在應用程式中加入新的連絡人，請在使用者儲存該資訊後立即將該資訊傳送至 Siri。

更重要的是，應用程式 _必須_ 立即刪除 Siri 詞彙中的資訊，因為如果使用者刪除了一項資訊，但 Siri 仍在稍後辨識該資訊的時間或天數，使用者可能會感到不滿意。

> [!IMPORTANT]
> 如果使用者選擇要重設應用程式或登出，應用程式應該移除 Siri 中的所有使用者特定詞彙。

## <a name="sirikit-permissions"></a>SiriKit 許可權

SiriKit 的最後一個部分是以許可權為中心。 就像使用 iOS (的其他功能（例如相片、相機或連絡人) ），使用者必須授與明確的許可權讓應用程式與 Siri 交談。

此應用程式可以提供字串來定義要提供給 Siri 的資訊，並提供原因讓使用者授與此存取權。

Apple 建議應用程式在使用者第一次將應用程式升級至 iOS 10 之後，要求使用者在第一次開啟應用程式時使用 Siri 的許可權。 如此一來，使用者就能瞭解 Siri 整合，並且可以在他們提出第一個要求之前，預先核准使用方式。

## <a name="sirikit-and-maps"></a>SiriKit 和 Maps

SiriKit 是 iOS 不可或缺的一部分，而且會使用新增至 iOS 10 的較大型意圖架構。 意圖架構是設計來與系統的其他部分共用一般和共用的動作和意圖。

意圖架構不僅超越 Siri 整合，還提供其他功能，例如連絡人整合，其中應用程式可以成為特定連絡人的預設電話語音或訊息應用程式。 意圖也提供與 CallKit 的深度整合，讓使用者能夠獲得最佳的 VOIP 體驗。

IOS 10 中的 Maps 應用程式已新增功能，例如共用，讓使用者可以直接在 Maps UI 內預訂。 SiriKit 提供具有對應的通用擴充點，因此可以在 Siri 和地圖之間共用共用 (和其他) 意圖。

這表示，如果應用程式採用 SiriKit 延伸模組，也會免費取得地圖服務整合。

## <a name="designing-a-great-siri-experience"></a>設計絕佳的 Siri 體驗

在將應用程式整合到 Siri 時設計絕佳的使用者體驗，與設計絕佳的應用程式使用者介面不同。 不同于使用者在螢幕上直接與應用程式互動的一般情況，當使用 Siri 時，有許多時候都沒有視覺介面可見。 例如，當使用者使用 *"嗨 Siri"* 開始交談時。

### <a name="how-siri-helps-the-developer"></a>Siri 如何協助開發人員

當您設計與 Siri 的應用程式互動時，應用程式會建立 *對話式介面*，這表示內容衍生自 Siri 與使用者代表應用程式的交談。

如果沒有視覺參考，使用者必須追蹤其標頭中顯示的資訊。 因此，Siri 會提供完成使用者想要完成之工作所需的最少資訊。

交談式介面是由使用者和 Siri 在交談期間的問題和回應所塑造。 因此，請務必考慮 Siri 在設計此介面時如何提出問題和回應。

以下列使用者建立訊息的範例為例，Siri 可能會以「 *準備寄送*」問題的方式回應。 使用者可以透過許多不同的方式來回應，例如「 *傳送*」、 *「取消」* 或甚至是與此問題完全無關的方式。 無論交談的播放方式為何，Siri 都會針對應用程式處理該應用程式，並只在其變成可用時，將相關資訊傳送給它。

有幾種不同的方式可讓使用者使用 Siri 起始對話：

- 藉由挑選裝置，按 [首頁] 按鈕。 在這種情況下，Siri 會呈現更多視覺介面和較不口頭的回應。
- 藉由說出「 *嗨 Siri* 」並開始進行手自由對話。 在這種情況下，Siri 會比較不適合視覺效果。
- 使用協助工具功能，例如啟用 bluetooth 的聽力，將會針對具有特殊需求的使用者量身打造 UI。
- 藉由將分散注意力保持在最少的位置，讓使用者在需要時持續關注。

### <a name="how-the-developer-helps-siri"></a>開發人員如何協助 Siri

在整合應用程式與 Siri 時，開發人員必須經常測試這項整合，並確保他們會以最多不同的方式，要求相同的資訊或工作片段，以進行許多不同的要求。

因為沒有兩人想要的，所以開發人員一定要盡可能取得不同的 Beta 測試人員，以協助微調 Siri 整合。 使用者可能會要求資訊或提出要求，而開發人員永遠不會這麼做，而這項微調可協助確保最廣泛的使用者群組在使用 Siri 的應用程式時，有絕佳的體驗。

在不同的情況和環境下進行測試。 以可確保這些交談保持流暢且自然的方式，使用 Siri 來起始交談。 在使用者不太可能使用應用程式的位置進行測試，例如在擁擠的 gym 中。

請確定應用程式提供 Siri 所需的所有資訊，以正確地代表使用者的要求和結果。 尤其是在手上自由情況下使用 Siri 時。

### <a name="siri-design-guidelines"></a>Siri 設計指導方針

請務必記住，Siri 會代表應用程式與使用者進行交談。 開發人員想要確定此交談保持流暢且自然的狀態。

如同任何重要的交談，開發人員必須確保下列各項：

- 應用程式已準備好進行交談。
- 應用程式會完全接聽使用者嘗試完成的工作。
- 應用程式會在適當的時間詢問適當的問題。
- 應用程式會使用使用者所搜尋的資訊來回應要求。

#### <a name="preparing-for-the-conversation"></a>準備進行對話

首先要記住的是，應用程式的使用者不會像開發人員一樣。 它們可能來自不同的背景、說出不同的語言，或在使用應用程式時有特殊的需求。

此外，由於開發人員是設計和建立應用程式，他們對應用程式及其內部工作和功能（一般使用者不會有）有深入的瞭解。 因此，開發人員可能會要求與一般使用者不同的 Siri 要求。

這就是為什麼有許多不同的人可以透過 Siri 與應用程式互動的原因很重要。 使用者可以透過開發人員從未想像過的 Siri 要求應用程式，或以開發人員不認為的方式提出要求。

#### <a name="ensure-the-app-is-a-good-listener"></a>確定應用程式是良好的接聽程式

開發人員必須確保應用程式是良好的接聽程式，並取得符合使用者期望的交談細節。 但也可能尚未提供應用程式完成所要求工作所需的所有資訊。

有幾種方式可讓應用程式處理這種情況：

- **針對遺漏值挑選良好的預設** 值-例如，如果使用者未指定要從中挑選它們的位置，則會將「共用應用程式」預設為使用者目前的位置。
- 使用應用程式收集在使用者上的特定資訊來**進行猜測**，應用程式可能會對遺失的資訊做出猜測，例如從使用者的連絡人資訊填寫遺失的行動電話號碼。 不過，請小心避免不良的意外，例如挑選最昂貴的選項等等。
- **提示取得詳細資訊** -應用程式可以讓 Siri 提示使用者提供遺漏值。 不過，這裡的關鍵是讓對話保持簡單和點。 如果使用者必須回答幾個問題才能達成其要求，就會很快就會感到挫折。
- 以**正常方式處理錯誤資訊**-使用者可能會提供應用程式未預期的值，或無法在指定的內容中處理的值。 確定應用程式將這種情況與使用者相關聯，讓使用者能夠清楚且輕鬆地修正。

當應用程式呈現有問題的單一值時，處理此問題的慣用方式是讓 Siri 要求使用者進行確認。 例如，「 *您的意思是 Bobo 很棒嗎？*」，他們可以使用簡單的 [是] 或 [否] 回答來回複。

如果有數個可能的選項對單一值而言是正確的，則會使用較不適當的處理方法。 在這種情況下，Siri 可能會提示使用者多達十個可能的選項來進行選擇。 例如：

```csharp
Who do you want to send the message to?

* Bobo the Great!
* Bobo Jr.
* Little Bobo
```

如果仍然有問題，請 Siri 提示使用者針對指定的值提供全新、更明確的答案。

#### <a name="request-final-confirmation"></a>要求最終確認

在應用程式實際執行工作以履行使用者的要求之前，Siri 會檢查應用程式延伸模組，以確定一切都已就緒。 例如，使用者的帳戶是否有足夠的金錢來進行要求的付款？

此外，應用程式必須確保它會提供所有可能的 Siri 資訊，讓它可以呈現給使用者，並確認要執行的工作符合其預期。

一旦使用者確認了要求，且應用程式已執行該要求，應用程式就必須再次確定它已將所有結果提供給 Siri，讓它可以與使用者建立關聯。

#### <a name="responding-to-the-request"></a>回應要求

Siri 有數個內建的使用者介面，適用于每個網域和其所知道的動作。 不過，在適當的情況下，應用程式可以提供自訂意圖 UI 延伸，藉由呈現應用程式的商標和 UI，或超過要求中的資訊，來豐富使用者體驗。

話雖如此，您應該在設計 Siri 的自訂介面時使用擋板。 一般來說，使用者想要儘快取得特定的工作，而且不想要使用不必要的資訊來多載。

也應該小心確保自訂 UI 在使用者可能擁有或使用裝置的所有不同 iOS 裝置和方向中正確地尋找和回應。

適當時，請使用 SiriKit API 來隱藏任何已存在於預設 Siri UI 中的多餘資訊。 此外，確定應用程式仍提供資訊給 Siri，讓它能夠在手上自由情況下呈現 verbally。

在某些情況下，Siri 可能會啟動應用程式來滿足使用者的要求，例如呈現使用者要求的相片。 在這些情況下，請不要令使用者驚訝。 顯示預期的資訊，而不需要進行中繼步驟或進一步的互動。 絕對不要顯示資訊或執行使用者未預期的工作。

### <a name="polishing-the-design"></a>修改設計

Apple 建議您執行幾個步驟，以將對話式介面的設計加以修飾。 首先，將清楚、簡潔的詞彙和使用案例範例提供給 Siri。

使用者探索應用程式的其中一種方式，是起始與 Siri 的交談，並詢問「*您可以怎麼做？* 」 Siri 將會顯示其所能執行的數個不同專案，包括開發人員的應用程式，以及透過其檔案提供的範例主圖使用案例 `plist` 。

如何撰寫良好的範例使用案例：

- 請確定範例包含應用程式名稱。
- 將範例保持簡短和指向。
- 針對應用程式支援的每個意圖提供多個範例。
- 根據應用程式最常見的使用案例，排列它們內意圖和範例的優先順序。
- 確定應用程式提供當地語系化的範例。
- 請確定所提供的每個範例在應用程式內都能如預期般運作。
- 避免在範例中定址 Siri，因此請勿包含 *"嗨 Siri ..."* 等文字
- 請避免任何不必要的 pleasantries，例如「 *請* 」或「 *感謝您*」。

請花適當的時間探索和實驗應用程式如何塑造 Siri 與使用者相關的交談。 請務必在整個過程中與一般使用者交談，因為他們與應用程式的互動和預期會隨著時間而改變。

請務必記得在不同的情況下測試應用程式，以及使用 Siri 叫用對話的所有不同方法。 在真實世界中測試使用者可能會使用應用程式，而不是來自辦公室和辦公桌。

致力於代表應用程式 (與 Siri 的交談) 為流體、自然和「感受」。

## <a name="summary"></a>摘要

本文涵蓋使用 SiriKit 所需的重要概念，並顯示它可以與 Xamarin iOS 應用程式互動，以提供可讓使用者使用 Siri 和 iOS 裝置上的 Maps 應用程式存取的服務。

## <a name="related-links"></a>相關連結

- [ElizaChat 範例](/samples/xamarin/ios-samples/ios10-elizachat)
- [SiriKit 程式設計指南](https://developer.apple.com/library/prerelease/content/documentation/Intents/Conceptual/SiriIntegrationGuide/index.html)
- [意圖架構參考](https://developer.apple.com/reference/intents)
- [意圖 UI 架構參考](https://developer.apple.com/reference/intentsui)